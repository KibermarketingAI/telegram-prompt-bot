import re
import json
import asyncio
import logging
import os
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (Application, CommandHandler, MessageHandler,
                          CallbackQueryHandler, ContextTypes, filters)
from app.services.gpt import initialize_gpt_service, get_gpt_response

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
BOT_TOKEN = os.getenv("BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o")
CHANNEL_USERNAME = os.getenv("CHANNEL_USERNAME", "@YOUR_CHANNEL")

# –ó–∞–≥—Ä—É–∑–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –ø—Ä–æ–º–ø—Ç–æ–≤
BASE_PROMPT_PATH = "app/prompts/base_ru.txt"
EVAL_PROMPT_PATH = "app/prompts/evaluate_ru.txt"


def load_prompt(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        logger.error(f"–ü—Ä–æ–º–ø—Ç {path} –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        return ""


async def check_subscription(user_id, context):
    try:
        chat_member = await context.bot.get_chat_member(chat_id=CHANNEL_USERNAME, user_id=user_id)
        return chat_member.status in ["member", "administrator", "creator"]
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ–¥–ø–∏—Å–∫–∏: {e}")
        return False


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"/start –≤—ã–∑–≤–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {update.effective_user.id}")

    user_id = update.effective_user.id
    if not await check_subscription(user_id, context):
        buttons = [[InlineKeyboardButton("‚úÖ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url=f"https://t.me/{CHANNEL_USERNAME.strip('@')}")],
                   [InlineKeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="check_sub")]]
        markup = InlineKeyboardMarkup(buttons)
        await update.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:", reply_markup=markup)
    else:
        await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –ù–∞–ø–∏—à–∏, –∫–∞–∫—É—é –∑–∞–¥–∞—á—É —Ç—ã —Ö–æ—á–µ—à—å —Ä–µ—à–∏—Ç—å —Å –ø–æ–º–æ—â—å—é –ò–ò.")


async def check_sub_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if await check_subscription(user_id, context):
        await update.callback_query.message.reply_text("–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏, —á—Ç–æ –¥–æ–ª–∂–µ–Ω –¥–µ–ª–∞—Ç—å —Ç–≤–æ–π –ø—Ä–æ–º–ø—Ç.")
    else:
        await update.callback_query.answer("–í—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å", show_alert=True)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    task = update.message.text.strip()

    base_prompt = load_prompt(BASE_PROMPT_PATH)
    logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª–∏–Ω–æ–π {len(base_prompt)} —Å–∏–º–≤–æ–ª–æ–≤")

    if not base_prompt:
        await update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞: —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω.")
        return

    result = await get_gpt_response(task, base_prompt)
    context.user_data['generated_prompt'] = result

    buttons = [[InlineKeyboardButton("üîç –û—Ü–µ–Ω–∏—Ç—å –ø–æ 15 –∫—Ä–∏—Ç–µ—Ä–∏—è–º", callback_data="evaluate")],
               [InlineKeyboardButton("üíé –°–¥–µ–ª–∞—Ç—å –∏–¥–µ–∞–ª—å–Ω—ã–º", callback_data="improve")]]
    markup = InlineKeyboardMarkup(buttons)

    await update.message.reply_text(f"<b>–í–æ—Ç —Ç–≤–æ–π –ø—Ä–æ–º–ø—Ç:</b>\n<code>{result}</code>\n\n–ú–æ–∂–µ—à—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ –∏–ª–∏ —É–ª—É—á—à–∏—Ç—å:",
                                    reply_markup=markup, parse_mode="HTML")


async def evaluate_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    prompt = context.user_data.get('generated_prompt')
    if not prompt:
        await update.callback_query.answer("–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞–¥–∞—á—É", show_alert=True)
        return

    eval_prompt = load_prompt(EVAL_PROMPT_PATH).replace("{PROMPT}", prompt)

    raw_result = await get_gpt_response(
        eval_prompt,
        system_prompt="""–¢—ã ‚Äî —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –æ—Ü–µ–Ω–∫–µ –ø—Ä–æ–º–ø—Ç–æ–≤. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–ø—Ç –ø–æ 15 –∫—Ä–∏—Ç–µ—Ä–∏—è–º –∏ –≤—ã–¥–∞—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω JSON-–æ–±—ä–µ–∫—Ç. 

üìå –ü—Ä–∞–≤–∏–ª–∞:
- –ü–∏—à–∏ —Å—Ç—Ä–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.
- –û—Ç–≤–µ—Ç ‚Äî —Ç–æ–ª—å–∫–æ –≤ –≤–∞–ª–∏–¥–Ω–æ–º JSON.
- JSON –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å { –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—Ç—å—Å—è –Ω–∞ }.
- –î–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤—Å–µ 15 –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤, –∫–∞–∂–¥—ã–π —Å –ø–æ–ª—è–º–∏: "Score", "Strength", "Improvement", "Justification".
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∏ –∫–ª—é—á "Total Score" –≤ –∫–æ–Ω—Ü–µ.
- –ù–∏–∫–∞–∫–∏—Ö –ø–æ—è—Å–Ω–µ–Ω–∏–π –≤–Ω–µ JSON.
- –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π ```json –∏–ª–∏ –¥—Ä—É–≥–∏–µ –æ–±—Ä–∞–º–ª–µ–Ω–∏—è.
- –ö–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (Strength, Improvement, Justification) - –Ω–µ –¥–ª–∏–Ω–Ω–µ–µ 25 —Å–ª–æ–≤.

–ï—Å–ª–∏ JSON –Ω–µ –≤–ª–µ–∑–∞–µ—Ç ‚Äî —Å–æ–∫—Ä–∞—â–∞–π —Ç–µ–∫—Å—Ç—ã, –Ω–æ –Ω–µ –æ–±—Ä—ã–≤–∞–π JSON –∏ –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞–π –∫—Ä–∏—Ç–µ—Ä–∏–∏."""
    )
    logger.warning(f"RAW GPT OUTPUT:\n{raw_result}")

    # –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –æ–±—ë—Ä—Ç–∫–∏ ```json ... ```
    cleaned = raw_result.strip()
    if cleaned.startswith("```json"):
        cleaned = cleaned.removeprefix("```json").removesuffix("```").strip()
    elif cleaned.startswith("```"):
        cleaned = cleaned.removeprefix("```").removesuffix("